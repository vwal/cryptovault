#!/bin/bash

#set -x

# color defs
# Reset
Color_Off='\033[0m'       # Text Reset

# Regular Colors
Black='\033[0;30m'        # Black
Red='\033[0;31m'          # Red
Green='\033[0;32m'        # Green
Yellow='\033[0;33m'       # Yellow
Blue='\033[0;34m'         # Blue
Purple='\033[0;35m'       # Purple
Cyan='\033[0;36m'         # Cyan
White='\033[0;37m'        # White

# Bold
BBlack='\033[1;30m'       # Black
BRed='\033[1;31m'         # Red
BGreen='\033[1;32m'       # Green
BYellow='\033[1;33m'      # Yellow
BBlue='\033[1;34m'        # Blue
BPurple='\033[1;35m'      # Purple
BCyan='\033[1;36m'        # Cyan
BWhite='\033[1;37m'       # White

# Underline
UBlack='\033[4;30m'       # Black
URed='\033[4;31m'         # Red
UGreen='\033[4;32m'       # Green
UYellow='\033[4;33m'      # Yellow
UBlue='\033[4;34m'        # Blue
UPurple='\033[4;35m'      # Purple
UCyan='\033[4;36m'        # Cyan
UWhite='\033[4;37m'       # White

# Background
On_Black='\033[40m'       # Black
On_Red='\033[41m'         # Red
On_Green='\033[42m'       # Green
On_Yellow='\033[43m'      # Yellow
On_Blue='\033[44m'        # Blue
On_Purple='\033[45m'      # Purple
On_Cyan='\033[46m'        # Cyan
On_White='\033[47m'       # White

# High Intensity
IBlack='\033[0;90m'       # Black
IRed='\033[0;91m'         # Red
IGreen='\033[0;92m'       # Green
IYellow='\033[0;93m'      # Yellow
IBlue='\033[0;94m'        # Blue
IPurple='\033[0;95m'      # Purple
ICyan='\033[0;96m'        # Cyan
IWhite='\033[0;97m'       # White

# Bold High Intensity
BIBlack='\033[1;90m'      # Black
BIRed='\033[1;91m'        # Red
BIGreen='\033[1;92m'      # Green
BIYellow='\033[1;93m'     # Yellow
BIBlue='\033[1;94m'       # Blue
BIPurple='\033[1;95m'     # Purple
BICyan='\033[1;96m'       # Cyan
BIWhite='\033[1;97m'      # White

# High Intensity backgrounds
On_IBlack='\033[0;100m'   # Black
On_IRed='\033[0;101m'     # Red
On_IGreen='\033[0;102m'   # Green
On_IYellow='\033[0;103m'  # Yellow
On_IBlue='\033[0;104m'    # Blue
On_IPurple='\033[0;105m'  # Purple
On_ICyan='\033[0;106m'    # Cyan
On_IWhite='\033[0;107m'   # White


#reset sudo cache timer if set previously
sudo -k
is_sudo=0
SUDOPWD=

login_user=$(logname)
current_user=`whoami`
im_root=0

CRYPTPWD=

# Define the dialog exit status codes
: ${DIALOG_OK=0}
: ${DIALOG_CANCEL=1}

# FUNCTIONS ==================================================================

exists()
{
  command -v "$1" >/dev/null 2>&1
}

validate_sudopwd()
{
  if [ "$is_sudo" = "1" ] ; then
    clear
    break
  else
    dialog --title "ERROR" --msgbox '\nINCORRECT SUDO PASSWORD!\n\nPlease try again!' 9 30
  fi
}

get_sudo_pwd()
{
  # get password
  while true; do
    SUDOPWD=$(dialog --title "Enter sudo password" --insecure --passwordbox "\nThis script requires sudo access. Please enter your sudo password (your login password) to be used for the elevated script operations. The password will be cached internally by this script.\n\n" 14 50  2>&1 > /dev/tty)
    ret=$?

    sudo -k
    echo ${SUDOPWD} | sudo -S -v &> /dev/null

    # evaluate sudo password test
    if [ $? -ne 0 ]; then 
      is_sudo=0;
    else
      is_sudo=1;
    fi    

    # ok (proceed) / cancel
    case $ret in
      0)
        validate_sudopwd;;
      1)
        exit 1;;
    esac
  done
}

# use the locally cached sudo password if sudo doesn't cache the password by policy (or if it has expired)
sudoit()
{
  if [ "$im_root" -eq 0 ] ; then
    if sudo -n true 2>/dev/null; then 
      sudo "$@"
    else
      echo ${SUDOPWD} | sudo -S "$@"  &> /dev/null
    fi
  else
    # running as root, no sudo needed
    "$@"
  fi
}

sudoitas()
{
  sudo_user=$1
  shift
  if sudo -n true 2>/dev/null; then 
    sudo -u $sudo_user "$@"
  else
    echo ${SUDOPWD} | sudo -S -u $sudo_user "$@"  &> /dev/null
  fi
}

find_existing_parent()
{
  pathname="$2"

  IFS='/' read -r -a p <<<"${pathname#/}"

  pa=""
  max="${#p[@]}"
  i=0
  while (( i<"$max" )); do
    paprev=$pa
    pa="$pa/${p[i++]}"
    if [[ ! -e $pa ]]; then
      eval "$1=$paprev"
      break
    fi
  done
}

find_dir_owner()
{
  dirowner=$(ls -ld $2 | awk '{print $3}')
  eval "$1=$dirowner"
}

# INITIAL CHECKS =============================================================

if ! exists dialog ; then
  printf "\n*************************************************************************************************\n\
This script requires dialog. Install it first with 'sudo apt-get install dialog', then try again!\n\
*************************************************************************************************\n\n"
  exit 1
fi

if [ "$EUID" -ne 0 ] ; then
  if [ $is_sudo -eq 0 ] ; then
    get_sudo_pwd
  fi
else
  im_root=1  
fi

CRYPTSETUP=`sudo which cryptsetup`
if [ $? -ne 0 ] ; then
  printf "\n*********************************************************************************************************\n\
This script requires cryptsetup. Install it first with 'sudo apt-get install cryptsetup', then try again!\n\
*********************************************************************************************************\n\n"
  exit 1
fi


# QUERY DISK DETAILS

# file system ext4 / zfs
#  -> check that zfsutils-linux is installed if zfs is selected
# cryptdisk file location
#  -> check write permissions user/sudo
# http://stackoverflow.com/questions/14103806/bash-test-if-a-directory-is-writable-by-a-given-uid
# disk file size
#  -> check min filesize of 128MB
#  -> check available disk space for the requested disk size
# cryptdisk label (suggest same as filename), but check /dev/mapper for active name conflicts
# disk password (2x)


# MAIN LOGIC: QUERY VAULT PARAMETERS

# FILE SYSTEM SELECTION
CRYPTFSSEL=$(dialog --title "Select crypto vault file system" --radiolist "\nSelect the file system for the encrypted vault.\nZFS is recommended for multiple reasons.\n\n" 12 55 2 \
            1 zfs on \
            2 ext4 off \
          2>&1 > /dev/tty)
ret=$?

# ok (proceed) / cancel
case $ret in
  0)
    ;;
  1)
    exit 1;;
esac

if [ "$CRYPTFSSEL" = "1" ] ; then
  CRYPTFS=zfs

  ZFS=`sudo which zfs`
  if [ $? -ne 0 ] ; then
    printf "\n\n******************************************************************************************************************************\n\
To use ZFS filesystem zfsutils-linux is required. Install it first with 'sudo apt-get install zfsutils-linux', then try again!\
\n******************************************************************************************************************************\n\n\n"
    exit 1
  fi

else
  CRYPTFS=ext4
fi


# ENCRYPTION PASSWORD SELECTION
while true; do
  CRYPTPWD1=$(dialog --title "Enter encryption password" --insecure --passwordbox "\nEnter the passphrase you want the vault to be encrypted with.\n\n" 12 50  2>&1 > /dev/tty)
  ret=$?

  # ok (proceed) / cancel
  case $ret in
    0)
      ;;
    1)
      exit 1;;
  esac

  CRYPTPWD2=$(dialog --title "Repeat encryption password" --insecure --passwordbox "\nEnter again the passphrase you want the vault to be encrypted with.\n\n" 12 50 2>&1 > /dev/tty)
  ret=$?

  # ok (proceed) / cancel
  case $ret in
    0)
      ;;
    1)
      exit 1;;
  esac

  if [ "$CRYPTPWD1" = "$CRYPTPWD2" ] ; then

    if [ "$CRYPTPWD1" = "" ] ; then
      dialog --title "ERROR" --msgbox '\nAn empty passphrase is not allowed!\n\nPlease try again!' 9 30
    else 
      CRYPTPWD=$CRYPTPWD1
      break
    fi
  else
    dialog --title "ERROR" --msgbox '\nPASSPHRASES DO NOT MATCH!!\n\nPlease try again!' 9 30
  fi
done

# VAULT SIZE SELECTION
while true; do
  CRYPTOVAULTSIZEINPUT=$(dialog --title "Enter desired crypto vault size" --inputbox "\nEnter the desired vault size in\nmegabytes (MB) or gigabytes (GB).\n\nPlease be mindful of the available drive space.\n\n" 14 55 512MB 2>&1 > /dev/tty)
  ret=$?

  # ok (proceed) / cancel
  case $ret in
    0)
      ;;
    1)
      exit 1;;
  esac
  
  if [[ $CRYPTOVAULTSIZEINPUT =~ ^([0-9]+)[[:space:]]*(MB|Mb|mb|GB|Gb|gb)$ ]] ; then
  
    #TODO: MIN 128MB CHECK WHEN ZFS IS IN EFFECT
    #TODO: Available disk space check
  
    VAULTSIZEVAL=${BASH_REMATCH[1]}
    VAULTSIZEUNIT=$(echo "${BASH_REMATCH[2]}" | awk '{print toupper($0)}')
    break
  else
    dialog --title "ERROR" --msgbox '\nUnacceptable vault size!\n\nPlease enter the numeric size (integers only), followed by "MB" or "GB"!' 14 50
  fi
  
done

# VAULT FILE LOCATION

# TODO: Check for existence of file with the same name
# TODO: normalize slash in the end of VAULT and MOUNT paths
# TODO: vault file and the mountpoint location should probably be owned by the same user (this check will occur with mountpoint)

while true; do
  dialog --title "Vault file location selection" --msgbox '\nOn the next screen select the location where you want the vault file to be saved. 
If this is a system-wide vault, use a path, for example, under /var/ (such as /var/vaultfiles/). For a personal vault, select a location under a home directory (e.g. /home/alice/vaultfiles/).\n\n
NOTE: In this step you will select the directory where the vault file is saved. In the next step you will select the vault file name/label.\n\n
NOTE: Use Up/Dn [arrow] to move to move the selector, SPACE to copy selected directory to the edit line, and ENTER to accept the current path in the edit box. 
To move to subdir/parent, add/remove "/" after the directory name on the edit line.\n\n
NOTE: If a non-existent path is entered, the directory/directories will be created.' 25 70

  VAULTPATH=$(dialog --title "Vault file location selection" --dselect ${HOME}/ 16 60 2>&1 > /dev/tty)
  ret=$?
  
  case $ret in
    0)
      ;;
    1)
      exit 1;;
  esac

  find_existing_parent vaultpath_existing_parent $VAULTPATH
  find_dir_owner vaultpath_parent_owner $vaultpath_existing_parent
  PATHMORE=''
  if [ "$current_user" != "$vaultpath_parent_owner" ]; then
    if [ "$vaultpath_parent_owner" = "root" ]; then
      PATHMORE="The selected location a system location, and will be owned by the root user.\n\n"
    else
      PATHMORE="The selected location is owned by user $vaultpath_parent_owner, and the vault file will be made private to that user.\n\n"
    fi
  fi

  PATHDETAIL=''
  if [ ! -d "$VAULTPATH" ]; then
    PATHDETAIL="This directory does not exist; it will be created."
  fi

  dialog --title "Confirm selected vault file location" --yesno "\nYou selected vault file location:\n\n${VAULTPATH}\n\n${PATHDETAIL}\n\n${PATHMORE}Is this what you want?" 16 70
  ret=$?
  
  case $ret in
    0)
      break;;
    1)
      ;;
  esac
  
done


# VAULT LABEL/FILE NAME
while true; do
  CRYPTOVAULTLABELINPUT=$(dialog --title "Crypto Vault Label/File Name" --inputbox "\nEnter the desired vault label (no spaces). It will also be used as the vault file name.\n\n
NOTE: Since vaults are mapped through /dev/mapper system-wide (even when access is limited to a specific user), the label must be unique.\n" 14 55 2>&1 > /dev/tty)
  ret=$?

  # ok (proceed) / cancel
  case $ret in
    0)
      ;;
    1)
      exit 1;;
  esac

  CRYPTOVAULTLABEL=$(echo "${CRYPTOVAULTLABELINPUT// /}")

  mapper_conflict=false
  for i in /dev/mapper/*; do
    thisbase=$(basename $i)
    if [ "$thisbase" = "$CRYPTOVAULTLABEL" ]; then
      mapper_conflict=true
    fi
  done

  if [ "$mapper_conflict" = "true" ]; then
    dialog --title "ERROR" --msgbox "\nThe crypto vault label you have chosen ($CRYPTOVAULTLABEL) conflicts with an already mapped vault. Please choose another label/filename!" 14 50
    ret=$?
  
    case $ret in
      0)
        ;;
      1)
        exit 1;;
    esac

  else
    VAULTFQFN=${VAULTPATH}/${CRYPTOVAULTLABEL}
    dialog --title "Confirm selected label/filename" --yesno "\nYou selected vault label / file name:\n\n${CRYPTOVAULTLABEL}\n\nThe full vault file path will be:\n\n${VAULTFQFN}\n\nIs this what you want?" 16 70
    ret=$?
  
    case $ret in
      0)
        break;;
      1)
        ;;
    esac

  fi

done


# VAULT MOUNTPOINT

while true; do
  dialog --title "Mountpoint selection" --msgbox '\nOn the next screen select the location where you want the vault to be mounted when opened. 
If this is a system-wide vault, use a path under /mnt/. For a personal vault, select a mountpoint under a home directory.\n\n
NOTE: Use Up/Dn [arrow] to move to move the selector, SPACE to copy selected directory to the edit line, and ENTER to accept the current path in the edit box. 
To move to subdir/parent, add/remove "/" after the directory name on the edit line.\n\n
NOTE: If a non-existent path is entered, the directory/directories will be created. Existing but non-empty directories are not accepted.\n\n
NOTE: Global locations (e.g. /mnt/mountdir) are set up for root access, while user-owned locations (e.g. /home/alice/mountdir) are set up for the owner of the parent dir (i.e. "alice" in this example).' 25 70

  MOUNTPATH=$(dialog --title "Mount point selection" --dselect ${HOME}/ 16 60 2>&1 > /dev/tty)
  ret=$?
  
  case $ret in
    0)
      ;;
    1)
      exit 1;;
  esac

  PATHDETAIL=
  confirm=false
  mountpoint_exists=true
  if [ -d "$MOUNTPATH" ]; then
    if [ "$(ls -A $MOUNTPATH)" ]; then
      PATHDETAIL="This directory is not empty.\n\nSelect an empty directory, or create new."
    else
      PATHDETAIL="This directory exists and it is empty."
      confirm=true
    fi
  else
    find_existing_parent mountpath_existing_parent $MOUNTPATH
    find_dir_owner mountpath_parent_owner $mountpath_existing_parent
    PATHMORE=''
    if [ "$current_user" != "$mountpath_parent_owner" ]; then
      if [ "$mountpath_parent_owner" = "root" ]; then
        PATHMORE="The selected mount path is a system location, and will be owned by the root user.\n\n"
      else
        PATHMORE="The selected location is owned by user $mountpath_parent_owner, and the mountpoint will be made private to that user.\n\n"
      fi
    fi

    PATHDETAIL="This directory does not exist; it will be created."
    confirm=true
    mountpoint_exists=false
  fi

  if [ "$confirm" = "true" ]; then
    dialog --title "Confirm selected mountpoint" --yesno "\nYou selected mount path:\n\n${MOUNTPATH}\n\n${PATHDETAIL}\n\n${PATHMORE}Is this what you want?" 16 70
    ret=$?
  
    case $ret in
      0)
        break;;
      1)
        ;;
    esac
  
  else
    dialog --title "ERROR" --msgbox "\n$PATHDETAIL" 14 50
  fi
  
done

if [ "$mountpoint_exists" = "false" ]; then
  if [ "$current_user" = "$mountpath_parent_owner" ]; then
    mkdir -p $MOUNTPATH
  else
    sudoitas $mountpath_parent_owner mkdir -p $MOUNTPATH
  fi
fi


# review..
echo "Crypto FS: $CRYPTFS"
echo "Crypto PWD: $CRYPTPWD"
echo "Crypto vault size: $VAULTSIZEVAL"
echo "Crypto vault size unit: $VAULTSIZEUNIT"
echo "Crypto vault label/filename: $CRYPTOVAULTLABEL"
echo "Crypto vault file location: $VAULTPATH"
echo "Crypto vault file location ownership: "
echo "Crypto vault mountpath: $MOUNTPATH"
echo "Crypto vault mountpath ownership: $mountpath_parent_owner"

# create mount/umount scripts

echo -e "\e${BWhite}\e${On_Red} ELEVATED: \e${Color_Off} touch /root/testfile25"
sudoit touch /root/testfile25
