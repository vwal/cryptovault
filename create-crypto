#!/bin/bash

#set -x

# color defs
# Reset
Color_Off='\033[0m'       # Text Reset

# Regular Colors
Black='\033[0;30m'        # Black
Red='\033[0;31m'          # Red
Green='\033[0;32m'        # Green
Yellow='\033[0;33m'       # Yellow
Blue='\033[0;34m'         # Blue
Purple='\033[0;35m'       # Purple
Cyan='\033[0;36m'         # Cyan
White='\033[0;37m'        # White

# Bold
BBlack='\033[1;30m'       # Black
BRed='\033[1;31m'         # Red
BGreen='\033[1;32m'       # Green
BYellow='\033[1;33m'      # Yellow
BBlue='\033[1;34m'        # Blue
BPurple='\033[1;35m'      # Purple
BCyan='\033[1;36m'        # Cyan
BWhite='\033[1;37m'       # White

# Underline
UBlack='\033[4;30m'       # Black
URed='\033[4;31m'         # Red
UGreen='\033[4;32m'       # Green
UYellow='\033[4;33m'      # Yellow
UBlue='\033[4;34m'        # Blue
UPurple='\033[4;35m'      # Purple
UCyan='\033[4;36m'        # Cyan
UWhite='\033[4;37m'       # White

# Background
On_Black='\033[40m'       # Black
On_Red='\033[41m'         # Red
On_Green='\033[42m'       # Green
On_Yellow='\033[43m'      # Yellow
On_Blue='\033[44m'        # Blue
On_Purple='\033[45m'      # Purple
On_Cyan='\033[46m'        # Cyan
On_White='\033[47m'       # White

# High Intensity
IBlack='\033[0;90m'       # Black
IRed='\033[0;91m'         # Red
IGreen='\033[0;92m'       # Green
IYellow='\033[0;93m'      # Yellow
IBlue='\033[0;94m'        # Blue
IPurple='\033[0;95m'      # Purple
ICyan='\033[0;96m'        # Cyan
IWhite='\033[0;97m'       # White

# Bold High Intensity
BIBlack='\033[1;90m'      # Black
BIRed='\033[1;91m'        # Red
BIGreen='\033[1;92m'      # Green
BIYellow='\033[1;93m'     # Yellow
BIBlue='\033[1;94m'       # Blue
BIPurple='\033[1;95m'     # Purple
BICyan='\033[1;96m'       # Cyan
BIWhite='\033[1;97m'      # White

# High Intensity backgrounds
On_IBlack='\033[0;100m'   # Black
On_IRed='\033[0;101m'     # Red
On_IGreen='\033[0;102m'   # Green
On_IYellow='\033[0;103m'  # Yellow
On_IBlue='\033[0;104m'    # Blue
On_IPurple='\033[0;105m'  # Purple
On_ICyan='\033[0;106m'    # Cyan
On_IWhite='\033[0;107m'   # White


#reset sudo cache timer if set previously
sudo -k
is_sudo=0
SUDOPWD=

login_user=$(logname)
current_user=`whoami`
im_root=0

CRYPTPWD=

# Define the dialog exit status codes
: ${DIALOG_OK=0}
: ${DIALOG_CANCEL=1}

# FUNCTIONS ==================================================================

exists()
{
  command -v "$1" >/dev/null 2>&1
}

validate_sudopwd()
{
  if [ "$is_sudo" = "1" ] ; then
    break
  else
    dialog --title "ERROR" --msgbox "\nINCORRECT SUDO PASSWORD!\n\nPlease try again!" 9 30
  fi
}

get_sudo_pwd()
{
  # get password
  while true; do
    SUDOPWD=$(dialog --title "Enter sudo password" --insecure --passwordbox "\nThis script requires sudo access. Please enter your sudo password (your login password) to be used for the elevated script operations. The password will be cached internally by this script, but depending on your system policy, you may be re-prompted for sudo password later.\n\n" 13 60  2>&1 > /dev/tty)
    ret=$?

    sudo -k
    echo ${SUDOPWD} | sudo -S -v &> /dev/null

    # evaluate sudo password test
    if [ $? -ne 0 ]; then 
      is_sudo=0;
    else
      is_sudo=1;
    fi    

    # ok (proceed) / cancel
    case $ret in
      0)
        validate_sudopwd;;
      1)
        exit 1;;
    esac
  done
}

# sudo for system operations
# use the locally cached sudo password if sudo doesn't cache the password by policy (or if it has expired)
sudoit()
{
  if [ "$im_root" -eq 0 ] ; then
    if sudo -n true 2>/dev/null; then 
      sudo "$@"
    else
      echo ${SUDOPWD} | sudo -S "$@"  &> /dev/null
    fi
  else
    # running as root, no sudo needed
    "$@"
  fi
}

# always sudo because executing as a different user
# use the locally cached sudo password if sudo doesn't cache the password by policy (or if it has expired)
sudoitas()
{
  sudo_user=$1
  shift
  if sudo -n true 2>/dev/null; then 
    sudo -u $sudo_user "$@"
  else
    echo ${SUDOPWD} | sudo -S -u $sudo_user "$@"  &> /dev/null
  fi
}

find_existing_parent()
{
  pathname="$2"

  if [ -d "$pathname" ]; then
    eval "$1=$2"  
  else
    IFS='/' read -r -a p <<<"${pathname#/}"

    pa=""
    max="${#p[@]}"
    i=0
    while (( i<"$max" )); do
      paprev=$pa
      pa="$pa/${p[i++]}"
      if [[ ! -e $pa ]]; then
        eval "$1=$paprev"
        break
      fi
    done
  fi
}

find_dir_owner()
{
  dirowner=$(ls -ld $2 | awk '{print $3}')
  eval "$1=$dirowner"
}

cleanup()
{
  echo
  echo -e "\e${BIRed}Cleaning up after interrupt...\e${Color_Off}"  

  # export zfs pool, umount ext4 fs
  if [ "$CRYPTOFS" = "zfs" ]; then
    sudoit zpool export $cryptopool
    echo "zfs pool exported."
  else
    sudoit umount ${MOUNTPATH}
    echo "ext4 filesystem unmounted at ${MOUNTPATH}."
  fi  

  # remove mapped disk
  if [ -b /dev/mapper/${CRYPTOVAULTLABEL} ]; then
    sudoit cryptsetup luksClose /dev/mapper/${CRYPTOVAULTLABEL}
    echo "Mapped device /dev/mapper/${CRYPTOVAULTLABEL} removed."
  fi

  if ! sudo -n true 2>/dev/null; then 
    echo -e "\e${IYellow}This operation requires you to re-enter your sudo password below:\e${Color_Off}"
  fi 
  # acquire loop device
  loopdev2del=`sudo losetup --raw | grep ${VAULTPATH}/${CRYPTOVAULTLABEL} | awk '{print $1}'`
  # delete loop device
  if [ "$loopdev2del" != "" ]; then
    sudoit losetup -d $loopdev2del > /dev/null 2>&1
    echo "Loop device $loopdev2del removed."
  fi
  echo "Exiting.."
  echo
  exit 1
}

# PREREQS CHECKS =============================================================

if ! exists dialog ; then
  printf "\n*************************************************************************************************\n\
This script requires dialog. Install it first with 'sudo apt-get install dialog', then try again!\n\
*************************************************************************************************\n\n"
  exit 1
fi

if [ "$EUID" -ne 0 ] ; then
  if [ $is_sudo -eq 0 ] ; then
    get_sudo_pwd
  fi
else
  im_root=1  
fi

CRYPTSETUP=`sudo which cryptsetup`
if [ $? -ne 0 ] ; then
  printf "\n*********************************************************************************************************\n\
This script requires cryptsetup. Install it first with 'sudo apt-get install cryptsetup', then try again!\n\
*********************************************************************************************************\n\n"
  exit 1
fi


# MAIN LOGIC: QUERY VAULT PARAMETERS =========================================

# FILE SYSTEM SELECTION
CRYPTOFSSEL=$(dialog --title "Select crypto vault file system" --radiolist "\nSelect the file system for the encrypted vault.\nZFS is recommended for multiple reasons.\n\n
NOTE: Highlight the choice with up/down arrow, select with SPACE." 20 55 2 \
            1 zfs on \
            2 ext4 off \
          2>&1 > /dev/tty)
ret=$?

# ok (proceed) / cancel
case $ret in
  0)
    ;;
  1)
    exit 1;;
esac

if [ "$CRYPTOFSSEL" = "1" ] ; then
  CRYPTOFS=zfs

  ZFS=`sudo which zfs`
  if [ $? -ne 0 ] ; then
    printf "\n\n******************************************************************************************************************************\n\
To use ZFS filesystem zfsutils-linux is required. Install it first with 'sudo apt-get install zfsutils-linux', then try again!\
\n******************************************************************************************************************************\n\n\n"
    exit 1
  fi

else
  CRYPTOFS=ext4
fi


# ENCRYPTION PASSWORD SELECTION
while true; do
  CRYPTPWD1=$(dialog --title "Enter encryption password" --insecure --passwordbox "\nEnter the passphrase you want the vault to be encrypted with.\n\n" 12 50  2>&1 > /dev/tty)
  ret=$?

  # ok (proceed) / cancel
  case $ret in
    0)
      ;;
    1)
      exit 1;;
  esac

  CRYPTPWD2=$(dialog --title "Repeat encryption password" --insecure --passwordbox "\nEnter again the passphrase you want the vault to be encrypted with.\n\n" 12 50 2>&1 > /dev/tty)
  ret=$?

  # ok (proceed) / cancel
  case $ret in
    0)
      ;;
    1)
      exit 1;;
  esac

  if [ "$CRYPTPWD1" = "$CRYPTPWD2" ] ; then

    if [ "$CRYPTPWD1" = "" ] ; then
      dialog --title "ERROR" --msgbox "\nAn empty passphrase is not allowed!\n\nPlease try again!" 9 30
    else 
      CRYPTPWD=$CRYPTPWD1
      break
    fi
  else
    dialog --title "ERROR" --msgbox "\nPASSPHRASES DO NOT MATCH!!\n\nPlease try again!" 9 30
  fi
done


# VAULT SIZE SELECTION
while true; do
  CRYPTOVAULTSIZEINPUT=$(dialog --title "Enter desired crypto vault size" --inputbox "\nEnter the desired vault size in\nmegabytes (MB) or gigabytes (GB).\n\nPlease be mindful of the available drive space.\n\n" 14 55 512MB 2>&1 > /dev/tty)
  ret=$?

  # ok (proceed) / cancel
  case $ret in
    0)
      ;;
    1)
      exit 1;;
  esac
  
  if [[ $CRYPTOVAULTSIZEINPUT =~ ^([0-9]+)[[:space:]]*(MB|Mb|mb|GB|Gb|gb)$ ]] ; then
    VAULTSIZEVAL=${BASH_REMATCH[1]}
    VAULTSIZEUNIT=$(echo "${BASH_REMATCH[2]}" | awk '{print toupper($0)}')

    zfssizefault=false
    if [ "$CRYPTOFS" = "zfs" ] &&
       [ "$VAULTSIZEUNIT" = "MB" ] &&
       [ $VAULTSIZEVAL -lt 128 ]; then
          zfssizefault=true
          dialog --title "ERROR" --msgbox "\nZFS filesystem requires minimum vault size of 128MB!" 8 60
    fi
    
    if [ "$zfssizefault" = "false" ]; then
      break
    fi
  else
    dialog --title "ERROR" --msgbox "\nUnacceptable vault size!\n\nPlease enter the numeric size (integers only), followed by \"MB\" or \"GB\"!" 14 50
  fi
  
done


# VAULT FILE LOCATION
if [ "$current_user" = "root" ]; then
  SYSTEMEXAMPLE="\nSuggested system-wide vault file location: /var/vaultfiles"
else
  SYSTEMEXAMPLE=''
fi

while true; do
  dialog --title "Vault file location selection" --msgbox "\nOn the next screen select the location where you want the vault file to be saved. 
If this is a system-wide vault, use a path, for example, under /var/ (such as /var/vaultfiles). For a personal vault, select a location under a home directory (e.g. /home/alice/vaultfiles).\n\n
NOTE: In this step you will select the directory where the vault file is saved. In the next step you will select the vault file name/label.\n\n
NOTE: Use Up/Dn [arrow] to move to move the selector, SPACE to copy selected directory to the edit line, and ENTER to accept the current path in the edit box. 
To move to subdir/parent, add/remove \"/\" after the directory name on the edit line.\n\n
NOTE: If a non-existent path is entered, the directory/directories will be created.\n\n
Suggested vault file location: ${HOME}/vaultfiles${SYSTEMEXAMPLE}" 25 75

  VAULTPATH=$(dialog --title "Vault file location selection" --dselect ${HOME}/ 16 60 2>&1 > /dev/tty)
  ret=$?

  #remove slash from the end if there is one
  VAULTPATH=${VAULTPATH%/}
  
  case $ret in
    0)
      ;;
    1)
      exit 1;;
  esac

  find_existing_parent vaultpath_existing_parent $VAULTPATH
  find_dir_owner vaultpath_owner $vaultpath_existing_parent

  PATHMORE=''
  if [ "$current_user" != "$vaultpath_owner" ]; then
    if [ "$vaultpath_owner" = "root" ]; then
      PATHMORE="The selected location a system location, and will be owned by the root user.\n\n"
    else
      PATHMORE="The selected location is owned by user \"$vaultpath_owner\", and the vault file will be made private to that user.\n\n"
    fi
  fi

  PATHDETAIL=''
  vaultpath_exists=true
  if [ ! -d "$VAULTPATH" ]; then
    PATHDETAIL="This directory does not exist; it will be created."
    vaultpath_exists=false
  fi

  dialog --title "Confirm selected vault file location" --yesno "\nYou selected vault file location:\n\n${VAULTPATH}\n\n${PATHDETAIL}\n\n${PATHMORE}Is this what you want?" 16 70
  ret=$?
  
  case $ret in
    0)
      break;;
    1)
      ;;
  esac
  
done


# VAULT LABEL/FILE NAME
while true; do
  CRYPTOVAULTLABELINPUT=$(dialog --title "Crypto Vault Label/File Name" --inputbox "\nEnter the desired vault label (no spaces). It will also be used as the vault file name.\n\n
NOTE: Since vaults are mapped through /dev/mapper system-wide (even when access is limited to a specific user), the label must be unique.\n" 14 55 2>&1 > /dev/tty)
  ret=$?

  # ok (proceed) / cancel
  case $ret in
    0)
      ;;
    1)
      exit 1;;
  esac

  CRYPTOVAULTLABEL=$(echo "${CRYPTOVAULTLABELINPUT// /}")

  vaultname_conflict=false
  mapper_conflict=false
  for i in /dev/mapper/*; do
    thisbase=$(basename $i)
    if [ "$thisbase" = "$CRYPTOVAULTLABEL" ]; then
      vaultname_conflict=true
      mapper_conflict=true
    fi
  done

  for i in $VAULTPATH/*; do
    thisbase=$(basename $i)
    if [ "$thisbase" = "$CRYPTOVAULTLABEL" ]; then
      vaultname_conflict=true
    fi
  done

  if [ "$vaultname_conflict" = "true" ]; then
    if [ "$mapper_conflict" = "true" ]; then
       vaultname_conflict_message="\nThe crypto vault label you have chosen ($CRYPTOVAULTLABEL) conflicts with an already mapped vault.\n\nPlease choose another label/filename!"
    else
       vaultname_conflict_message="\nThe crypto vault label you have chosen ($CRYPTOVAULTLABEL) conflicts with an existing vault file at your chosen vault file path ($VAULTPATH).\n\nPlease choose another label/filename!"
    fi    

    dialog --title "ERROR" --msgbox "$vaultname_conflict_message" 14 50
    ret=$?
  
    case $ret in
      0)
        ;;
      1)
        exit 1;;
    esac

  else
    VAULTFQFN=${VAULTPATH}/${CRYPTOVAULTLABEL}
    dialog --title "Confirm selected label/filename" --yesno "\nYou selected vault label / file name:\n\n${CRYPTOVAULTLABEL}\n\nThe full vault file path will be:\n\n${VAULTFQFN}\n\nIs this what you want?" 16 70
    ret=$?
  
    case $ret in
      0)
        break;;
      1)
        ;;
    esac

  fi

done


# VAULT MOUNTPOINT
if [ "$current_user" = "root" ]; then
  SYSTEMEXAMPLE="\nSuggested system-wide mountpoint location: /mnt/cryptodisk"
else
  SYSTEMEXAMPLE=''
fi

while true; do
  dialog --title "Mountpoint selection" --msgbox "\nOn the next screen select the location where you want the vault to be mounted when opened. 
If this is a system-wide vault, use a path under /mnt/. For a personal vault, select a mountpoint under a home directory.\n\n
NOTE: Use Up/Dn [arrow] to move to move the selector, SPACE to copy selected directory to the edit line, and ENTER to accept the current path in the edit box. 
To move to subdir/parent, add/remove \"/\" after the directory name on the edit line.\n\n
NOTE: If a non-existent path is entered, the directory/directories will be created. Existing but non-empty directories are not accepted. This directory can not be used for other purposes.\n\n
NOTE: Global locations (e.g. /mnt/mountdir) are set up for root access, while user-owned locations (e.g. /home/alice/mountdir) are set up for the owner of the parent dir (i.e. \"alice\" in this example).\n\n
Suggested mountpoint location: ${HOME}/cryptodisk${SYSTEMEXAMPLE}" 27 75

  MOUNTPATH=$(dialog --title "Mountpoint selection" --dselect ${HOME}/ 16 60 2>&1 > /dev/tty)
  ret=$?

  #remove slash from the end if there is one
  MOUNTPATH=${MOUNTPATH%/}
  
  case $ret in
    0)
      ;;
    1)
      exit 1;;
  esac

  find_existing_parent mountpath_existing_parent $MOUNTPATH
  find_dir_owner mountpath_owner $mountpath_existing_parent

  DIFF_OWNERS=''
  if [ "$vaultpath_owner" != "$mountpath_owner" ]; then
    DIFF_OWNERS="WARNING: THE VAULT FILE PATH ($VAULTPATH), AND THE MOUNTPOINT PATH ($MOUNTPATH) ARE OWNED BY DIFFERENT USERS (\"$vaultpath_owner\" and \"$mountpath_owner\", respectively). I can proceed, but this is *probably* not what you want!\n\n"
  fi



  PATHDETAIL=
  confirm=false
  mountpoint_exists=true
  if [ "$MOUNTPATH" = "$VAULTPATH" ]; then
    PATHDETAIL="Vault file path and the mountpoint cannot be the same directory; the mountpoint directory must always remain empty."
  else    
    if [ -d "$MOUNTPATH" ]; then
      if [ "$(ls -A $MOUNTPATH)" ]; then
        PATHDETAIL="This directory is not empty.\n\nSelect an empty directory, or create new."
      else
        PATHDETAIL="This directory exists and it is empty."
        confirm=true
      fi
    else
      PATHMORE=''
      if [ "$current_user" != "$mountpath_owner" ]; then
        if [ "$mountpath_owner" = "root" ]; then
          PATHMORE="The selected mountpoint path is a system location, and will be owned by the root user.\n\n"
        else
          PATHMORE="The selected location is owned by user \"$mountpath_owner\", and the mountpoint will be made private to that user.\n\n"
        fi
      fi

      PATHDETAIL="This directory does not exist; it will be created."
      confirm=true
      mountpoint_exists=false
    fi
  fi

  if [ "$confirm" = "true" ]; then
    dialog --title "Confirm selected mountpoint" --yesno "\n${DIFF_OWNERS}You selected mountpoint path:\n\n${MOUNTPATH}\n\n${PATHDETAIL}\n\n${PATHMORE}Is this what you want?" 22 75
    ret=$?
  
    case $ret in
      0)
        break;;
      1)
        ;;
    esac
  
  else
    dialog --title "ERROR" --msgbox "\n$PATHDETAIL" 14 50
  fi
  
done

dialog --title "Confirm to proceed" --yesno "\nIf you proceed, the encrypted vault will be created with the following parameters you have entered:\n\n
Vault filesystem: ${CRYPTOFS}\n
Vault size: ${VAULTSIZEVAL}${VAULTSIZEUNIT}\n
Vault label: ${CRYPTOVAULTLABEL}\n
Vault file path: ${VAULTPATH}/${CRYPTOVAULTLABEL} (owned by $vaultpath_owner)\n
Vault mount path: ${MOUNTPATH} (owned by $mountpath_owner)\n\n
If the values are not correct, cancel and run the script again.\n\nDo you want to proceed?" 22 80
ret=$?
  
case $ret in
  0)
    ;;
  1)
    clear && echo -e "\n\e${BWhite}\e${On_Red} SCRIPT WAS CANCELLED \e${Color_Off}\n\n" && exit 1;;
esac

# MAIN LOGIC: CREATE PATHS AND THE DISK ======================================

clear 

#-- dev
echo "Crypto FS: $CRYPTOFS"
echo "Crypto PWD: $CRYPTPWD"
echo "Crypto vault size: $VAULTSIZEVAL"
echo "Crypto vault size unit: $VAULTSIZEUNIT"
echo "Crypto vault label/filename: $CRYPTOVAULTLABEL"
echo "Crypto vault file location: $VAULTPATH"
echo "Crypto vault file location ownership: $vaultpath_owner"
echo "Crypto vault mountpath: $MOUNTPATH"
echo "Crypto vault mountpath ownership: $mountpath_owner"
echo
echo --
#-- dev

echo

trap cleanup INT ERR

executing="\e${BGreen}EXECUTING\e${Color_Off}"
if [ "$im_root" = "0" ]; then
  elevated=" \e${Black}\e${On_Green}ELEVATED\e${Color_Off}"
else
  elevated=''
fi

# create vault path
if [ "$vaultpath_exists" = "false" ]; then
  echo -e "\e${BIWhite}Creating vault path...\e${Color_Off}"
  executable="mkdir -p $VAULTPATH"
  if [ "$vaultpath_owner" = "$current_user" ]; then
    echo -e "$executing: $executable"
    eval $executable
  else
    echo -e "${executing}$elevated (as $vaultpath_owner): $executable"
    sudoitas $vaultpath_owner $executable
  fi
  
  if [ ! -d "$VAULTPATH" ]; then
    echo -e "\e${BWhite}\e${On_Red}Could not create vault path \"${VAULTPATH}\". Unable to proceed.\e${Color_Off}"
    cleanup
  fi
fi

echo

# create blank vault container file
echo -e "\e${BIWhite}Creating blank vault container file...\e${Color_Off}"
if [ "$VAULTSIZEUNIT" = "GB" ]; then
  let vaultsize=$VAULTSIZEVAL*1024
else
  vaultsize=$VAULTSIZEVAL
fi
executable="dd if=/dev/zero of=${VAULTPATH}/${CRYPTOVAULTLABEL} bs=1M count=$vaultsize"
if [ "$vaultpath_owner" = "$current_user" ]; then
  echo -e "$executing: $executable"
  eval $executable
else
  echo -e "${executing}$elevated (as $vaultpath_owner): $executable"
  sudoitas $vaultpath_owner $executable
fi
if [ ! -f "${VAULTPATH}/${CRYPTOVAULTLABEL}" ]; then
  echo -e "\e${BWhite}\e${On_Red}Could not create vault container file \"${VAULTPATH}/${CRYPTOVAULTLABEL}\". Unable to proceed.\e${Color_Off}"
  cleanup
fi

echo

# create mountpoint path
if [ "$mountpoint_exists" = "false" ]; then
  echo -e "\e${BIWhite}Creating mountpoint path...\e${Color_Off}"
  executable="mkdir -p $MOUNTPATH"
  if [ "$mountpath_owner" = "$current_user" ]; then
    echo -e "$executing: $executable"
    eval $executable
  else
    echo -e "${executing}$elevated (as $mountpath_owner): $executable"
    sudoitas $mountpath_owner $executable
  fi
  if [ ! -d "$MOUNTPATH" ]; then
    echo -e "\e${BWhite}\e${On_Red}Could not create mountpoint path \"${MOUNTPATH}\". Unable to proceed.\e${Color_Off}"
    cleanup
  fi
fi

echo

# format the container
echo -e "\e${BIWhite}Formatting the container with encrypted LUKS filesystem...\e${Color_Off}"
echo -e "${executing}$elevated: cryptsetup luksFormat -q ${VAULTPATH}/${CRYPTOVAULTLABEL}"

if [ "$im_root" -eq 0 ] ; then
  if ! sudo -n true 2>/dev/null; then 
    echo -e "\e${IYellow}This operation requires you to re-enter your sudo password below:\e${Color_Off}"
  fi
  echo -n "$CRYPTPWD" | sudo cryptsetup luksFormat -q ${VAULTPATH}/${CRYPTOVAULTLABEL} -
else
  # running as root, no sudo needed (even when creting for a different user, this is only access to cryptsetup command)
  echo -n "$CRYPTPWD" | cryptsetup luksFormat -q ${VAULTPATH}/${CRYPTOVAULTLABEL} -
fi

echo

# set up the loop device
echo -e "\e${BIWhite}Setting up the loop device...\e${Color_Off}"
if ! sudo -n true 2>/dev/null; then 
  echo -e "\e${IYellow}This operation requires you to re-enter your sudo password below:\e${Color_Off}"
fi
loopdev=`sudo losetup -f`
echo "Using loop device: $loopdev"
executable="losetup $loopdev ${VAULTPATH}/${CRYPTOVAULTLABEL}"
echo -e "${executing}$elevated: $executable"
sudoit $executable
# to confirm, pull label with $loopdev, compare to the label

echo

# open the mapped loop device (req. selected encryption password)
echo -e "\e${BIWhite}Opening the mapped device...\e${Color_Off}"
executable="cryptsetup luksOpen $loopdev ${CRYPTOVAULTLABEL}"
echo -e "${executing}$elevated: $executable"
echo -e "\e${IYellow}The encrypted device is being opened. Please enter below the encryption password\nyou selected earlier in the process (NOTE: typed characters will not echo).\e${Color_Off}"
sudoit $executable

echo

# create and mount the filesystem
echo -e "\e${BIWhite}Creating the ${CRYPTOFS} filesystem...\e${Color_Off}"
if [ "$CRYPTOFS" = "zfs" ]; then
  cryptopool="cryptopool-${CRYPTOVAULTLABEL}"
  echo "Cryptopool is: $cryptopool"
  executable="zpool create -o ashift=12 -O atime=off -O compression=lz4 -O normalization=formD -O mountpoint=/ -m ${MOUNTPATH} $cryptopool /dev/mapper/${CRYPTOVAULTLABEL}"
  echo -e "${executing}$elevated: $executable"  
  sudoit $executable
  echo "Currently mounted zfs pools on this system:"
  sudoit zfs list
else
  executable="mkfs.ext4 /dev/mapper/${CRYPTOVAULTLABEL}"
  echo -e "${executing}$elevated: $executable"
  sudoit $executable
  executable_mount="mount /dev/mapper/${CRYPTOVAULTLABEL} ${MOUNTPATH}"
  echo "Mounting ext4 filesystem.."
  echo -e "${executing}$elevated: $executable_mount"
  sudoit $executable_mount
fi

# test mount
mounttest=`mount | grep --color=never $cryptopool`
if [ "${mounttest}" = "" ]; then
  echo -e "\e${BWhite}\e${On_Red}Could not mount the crypt disk at  \"${MOUNTPATH}\". Unable to proceed.\e${Color_Off}"
  cleanup
fi

if [ "$mountpath_owner" != "root" ]; then
  echo "Setting mountpoint permissions.."
  executable="chmod 770 ${MOUNTPATH}"
  echo -e "${executing}$elevated: $executable"
  sudoit $executable
  executable="mount | grep cryptopool-mycryptdisk"
  echo -e "${executing}$elevated: $executable"
  sudoit $executable
fi

echo 

echo "Complete."

echo

#-- dev

read -p "Press any key to continue... " -n1 -s

dialog --title "Remove map/loop devices" --yesno "\nRemove the created map and loop devices?" 10 50
ret=$?
  
case $ret in
  0)
    cleanup;;
  1)
    ;;
esac

#-- dev



# CREATE ONLY: ✔
# dd if=/dev/zero of=crypt-disk-two bs=1M count=128

# CREATE ONLY: ✔
# sudo cryptsetup luksFormat -q ${VAULTPATH}/${CRYPTOVAULTLABEL}

# CREATE/OPEN: ✔
# sudo losetup -f;echo "The loop device in use is ${LDEV}"; sudo losetup $LDEV ${VAULTPATH}/${CRYPTOVAULTLABEL}

# CREATE/OPEN: ✔
# DNAM=${CRYPTOVAULTLABEL}; LDEV=`sudo losetup --raw | grep $DNAM | awk '{print $1}'`; sudo cryptsetup luksOpen $LDEV $DNAM

# CREATE ONLY: ✔
# zfs:
# sudo zpool create -o ashift=12 -O atime=off -O compression=lz4 -O normalization=formD -O mountpoint=/ -m ${MOUNTPATH} cryptopool-${CRYPTOVAULTLABEL} ${VAULTPATH}/${CRYPTOVAULTLABEL}
# ext4:
# sudo mkfs.ext4 /dev/mapper/${CRYPTOVAULTLABEL}

# --

# REOPEN:

# sudo zpool import pool-${CRYPTOVAULTLABEL}
# sudo zpool scrub pool-${CRYPTOVAULTLABEL}
# -or-
# sudo mount /dev/mapper/${CRYPTOVAULTLABEL} ${MOUNTPATH}

# --

# CLOSE:

# zfs:
# sudo zpool export pool-${CRYPTOVAULTLABEL}
# ext4:
# umount ${MOUNTPATH} > /dev/null 2>&1

# sudo cryptsetup luksClose /dev/mapper/${CRYPTOVAULTLABEL}

# DNAM=${CRYPTOVAULTLABEL}; LDEV=`sudo losetup --raw | grep $DNAM | awk '{print $1}'`; sudo losetup -d $LDEV

#TODO: create mount/umount scripts
